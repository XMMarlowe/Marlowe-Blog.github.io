---
title: JVM GC调优
author: Marlowe
tags:
  - GC
  - JVM
categories: Java
abbrlink: 30837
date: 2020-03-23 00:46:49
---
JVM调优入门...
<!--more-->

### JVM调优是必须的吗？

GC调优对于java服务是必须的吗？实际上，我感觉80%的java的程序员在实际工作中都没有碰到过GC调优吧，这是因为多数的Java应用不需要在服务器上进行GC优化，多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题，需要记住一点：**GC调优是最后要做的工作。**

GC调优的目的可以总结为下面两点：

* 减少对象晋升到老年代的数量
* 减少FullGC的执行时间

#### 减少对象晋升到老年代的数量
分代垃圾回收是Oracle JVM中回收思想。 我们知道在Eden区创建的对象，在from Survivor 复制到to Survivor区之后，达到一定年龄就进入了老年代(15次)。有些对象因为比较大就直接进入了老年代。在老年代的GC时间相比于年轻代时间更长。因此，减少对象进入老年代可以降低Full GC的频率。

#### 减少FullGC的执行时间

Full GC的时间比Minor GC要长。所以如果执行太长时间的Full GC（超过1秒），就会发生超时错误

* 如果你试着减少老年代的大小来降低Full GC的执行时间，可能会引发OutOfMemoryError或者导致Full GC的频率升高。
* 如果是通过增加老年代的大小来降低Full GC的频率，执行时间将会增加。


### 影响GC的参数

JVM调优主要用到参数罗列在下面的两张表中。主要分为内存参数和垃圾类型参数。GC优化的过程就是在调试这些参数的过程。

下表是与JVM内存相关的参数：

<center>

![20210415103509](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210415103509.png)
</center>

1.针对JVM堆的设置，一般可以通过-Xms -Xmx限定其最小、最大值，**为了防止垃圾收集器在最小、最大之间收缩堆而产生额外的时间，通常把最大、最小设置为相同的值;**

2.**年轻代和年老代将根据默认的比例（1：2）分配堆内存，** 可以通过调整二者之间的比率NewRadio来调整二者之间的大小，也可以针对回收代。

比如年轻代，通过 -XX:newSize -XX:MaxNewSize来设置其绝对大小。同样，为了防止年轻代的堆收缩，我们通常会把-XX:newSize -XX:MaxNewSize设置为同样大小。

### 一些问题

#### 如何进行JVM调优？
JVM调优主要就是通过定制VM运行参数来提高JAVA应用程度的运行数据

#### JVM参数有哪些？

JVM参数大致可以分为三类:
1. 标注指令: -开头，这些是所有的HotSpot都支持的参数。可以用java -help打印出来。
2. 非标准指令: -X开头， 这些指令通常是跟特定的HotSpot版本对应的。可以用java -X打印出来。
3. 不稳定参数: -XX开头，这一 -类参数是跟特定HotSpot版本对应的，并且变化非常大。详细的文档资料非常少。在JDK1.8版本下，有几个常用的不稳定指令:
* java -XX:+ PrintCommandLineFlags :查看当前命令的不稳定指令。
* java -XX:+ PrintFlagsInitial :查看所有不稳定指令的默认值。
* java -XX: + PrintFlagsFinal:查看所有不稳定指令 最终生效的实际值。


### 总结
JVM调优在实际工作中用到的比较少，但是这也是作为java程序员必须掌握的基本技能。**真正熟练的使用GC调优，是建立在多次进行GC监控和调优的实战经验上的。**

下面罗列了几个数据作为参考，如果GC执行时间满足下列所有条件，就没有必要进行GC优化了：

Minor GC执行非常迅速（50ms以内）

Minor GC没有频繁执行（大约10s执行一次）

Full GC执行非常迅速（1s以内）

Full GC没有频繁执行（大约10min执行一次）




### 参考
[JVM GC调优入门](https://www.jianshu.com/p/e7895f46f087)