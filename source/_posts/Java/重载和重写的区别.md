---
title: 重载和重写的区别
author: Marlowe
tags:
  - 重载
  - 重写
categories: Java
abbrlink: 57913
date: 2021-05-17 21:29:19
---

重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理

重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

<!--more-->

### 重载

发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

下面是《Java 核心技术》对重载这个概念的介绍：

![20210906143534](https://aishu-marlowe.oss-cn-beijing.aliyuncs.com/20210906143534.png)

综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。

#### 作用

方法重载就是让类以统一的方式处理不同类型的一种手段，调用方法时通过传递给他们的不同个数和类型的参数来决定具体使用哪个方法，这就是多态性。

#### 特点

重载发生在本类，方法名相同，参数列表不同，与返回值无关，只和方法名，参数的类型相关。

#### 原则

方法重载时，方法之间需要存在一定的练习，因为这样可以提高程序的可读性，并且我们一般只重载功能相似的方法。

#### 注意事项

1. 重载的方法必须具有不同的参数列表。
2. 不能通过访问权限，返回类型，抛出的异常进行重载。
3. 方法的异常类型和数目不会对重载造成影响。
4. 可以有不同的返回类类型，只要参数列表不同就可以了。
5. 可以有不同的访问修饰符。
6. 可以抛出不同的异常。

### 重写

重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。

1. 返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。
3. 构造方法无法被重写

综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。

#### 作用

重写体现了Java优越性，重写是建立在继承关系上的，它使语言结构更加丰富。在Java的继承中，子类既可以隐藏和访问父类的方法，也可以重写继承来的父类方法。这样方便了子类对父类方法的扩展。

#### 特点

方法的重写发生在继承类，实现类之中，重写后的方法与原方法有完全相同的返回值类型，方法名，参数个数以及参数类型，但是具体实现不同。

#### 注意事项

1. 方法名必须相同，返回类型必须相同
2. 参数列表必须相同
3. 访问权限不同比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明成protected。
4. 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
5. 构造方法不能被重写
6. 继承过程中如果父类当中的方法抛出异常，那么子类中重写父类的该方法时，也要抛出异常，且抛出的异常不能多于父类抛出的异常，例如父类抛出了IOException那么重写这个方法时就不能抛出Exception。

### 区别

![20210906144107](https://aishu-marlowe.oss-cn-beijing.aliyuncs.com/20210906144107.png)

方法的重写要遵循“两同两小一大”：

* “两同”即方法名相同、形参列表相同；
* “两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；
* “一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。

⭐️ 关于 重写的返回值类型 这里需要额外多说明一下，上面的表述不太清晰准确：如果方法的返回类型是 void 和基本数据类型，则返回值重写时不可修改。但是如果方法的返回值是引用类型，重写时是可以返回该引用类型的子类的。

```java
public class Hero {
    public String name() {
        return "超级英雄";
    }
}
public class SuperMan extends Hero{
    @Override
    public String name() {
        return "超人";
    }
    public Hero hero() {
        return new Hero();
    }
}

public class SuperSuperMan extends SuperMan {
    public String name() {
        return "超级超级英雄";
    }

    @Override
    public SuperMan hero() {
        return new SuperMan();
    }
}
```