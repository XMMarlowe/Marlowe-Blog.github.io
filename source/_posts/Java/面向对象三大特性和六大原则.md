---
title: 面向对象三大特性和六大原则
author: Marlowe
tags: 对象
categories: Java
abbrlink: 3706
date: 2021-06-01 09:51:59
---

<!--more-->

### 对象的概念

Java 是面向对象的编程语言，对象就是面向对象程序设计的核心。所谓对象就是真实世界中的实体，对象与实体是一一对应的，也就是说现实世界中每一个实体都是一个对象，它是一种具体的概念。对象有以下特点：

* 对象具有属性和行为。
* 对象具有变化的状态。
* 对象具有唯一性。
* 对象都是某个类别的实例。
* 一切皆为对象，真实世界中的所有事物都可以视为对象。


### 三大特性

面向对象开发模式更有利于人们开拓思维，在具体的开发过程中便于程序的划分，方便程序员分工合作，提高开发效率。

该开发模式之所以使程序设计更加完善和强大，主要是因为面向对象具有继承、封装和多态 3 个核心特性。

#### 封装

在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。

封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。

要访问该类的代码和数据，必须通过严格的接口控制。

封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。

适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。

##### 封装的概念

Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。

##### 封装的优点

1. 良好的封装能够减少耦合。
2. 类内部的结构可以自由修改。
3. 可以对成员变量进行更精确的控制。
4. 隐藏信息，实现细节。

Java 封装，说白了就是将一大坨公共通用的实现逻辑玩意，装到一个盒子里（class），出入口都在这个盒子上。你要用就将这个盒子拿来用，连接出入口，就能用了，不用就可以直接扔，对你代码没什么影响。

##### 封装的目的

1. 偷懒，辛苦一次，后面都能少敲很多代码，增强了代码得复用性
2. 简化代码，看起来更容易懂
3. 隐藏核心实现逻辑代码，简化外部逻辑，并且不让其他人修改，jar 都这么干
4. 一对一，一个功能就只为这个功能服务；避免头发绳子一块用，导致最后一团糟

##### Java 中的内部类

　内部类（ Inner Class ）就是定义在另外一个类**里面**的类。与之对应，包含内部类的类被称为外部类。

　那么问题来了：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！

　答：内部类的主要作用如下：

1. 内部类提供了**更好的封装**，可以把内部类**隐藏**在外部类之内，**不允许**同一个包中的其他类访问该类。

2. 内部类的方法可以**直接访问外部类的所有数据**，包括**私有的数据**。

3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。

内部类可分为以下几种：

* 成员内部类
* 静态内部类
* 方法内部类
* 匿名内部类　　


#### 继承

继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。

继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

![20210601095800](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210601095800.png)

兔子和羊属于食草动物类，狮子和豹属于食肉动物类。

食草动物和食肉动物又是属于动物类。

所以继承需要符合的关系是：is-a，父类更通用，子类更具体。

虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。

#### 多态

多态是同一个行为具有多个不同表现形式或形态的能力。

多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：

![20210601095829](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210601095829.png)

多态性是对象多种表现形式的体现。

> 现实中，比如我们按下 F1 键这个动作：

* 如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；
* 如果当前在 Word 下弹出的就是 Word 帮助；
* 在 Windows 下弹出的就是 Windows 帮助和支持。

同一个事件发生在不同的对象上会产生不同的结果。

##### 多态的好处

**可替换性（substitutability）**：多态对已存在代码具有可替换性。例如，多态对圆Circle类工作，对其他任何圆形几何体，如圆环，也同样工作。

**可扩充性（extensibility）**：多态对代码具有可扩充性。增加新的子类不影响已存在类的多态性、继承性，以及其他特性的运行和操作。实际上新加子类更容易获得多态功能。例如，在实现了圆锥、半圆锥以及半球体的多态基础上，很容易增添球体类的多态性。

**接口性（interface-ability）**：多态是超类通过方法签名，向子类提供了一个共同接口，由子类来完善或者覆盖它而实现的。

**灵活性（flexibility）**：它在应用中体现了灵活多样的操作，提高了使用效率。

**简化性（simplicity）**：多态简化对应用软件的代码编写和修改过程，尤其在处理大量对象的运算和操作时，这个特点尤为突出和重要。

子代父类实例化，然后就相当于一个父亲有很多儿子，送快递的给这个父亲的儿子送东西，他只需要送到父亲的家就行了，至于具体是那个儿子的，父亲还会分不清自己的儿子么，所以你就不用操心了。

**使用多态是一种好习惯** 多态方式声明是一种好的习惯。当我们创建的类，使用时，只用到它的超类或接口定义的方法时，我们可以将其索引声明为它的超类或接口类型。

它的好处是，如果某天我们对这个接口方法的实现方式变了，对这个接口又有一个新的实现类，我们的程序也需要使用最新的实现方式，此时只要将对象实现修改一下，索引无需变化。

比如Map< String,String> map = new HashMap < String,String>();

想换成HashTable实现，可以Map< String,String> map = new HashTable < String,String>();

比如写一个方法，参数要求传递List类型，你就可以用List list = new ArrayList()中的list传递，但是你写成ArrayList list = new ArrayList()是传递不进去的。尽管方法处理时都一样。另外，方法还可以根据你传递的不同list（ArrayList或者LinkList）进行不同处理。

### 六大原则

面向对象的三大特性是"封装、"多态"、"继承"，五大原则是"单一职责原则"、"开放封闭原则"、"里氏替换原则"、"依赖倒置原则"、"接口分离原则"、"迪米特原则（高内聚低耦合）"。

#### 单一职责原则SRP(Single Responsibility Principle)

是**指一个类的功能要单一，不能包罗万象**。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

#### 开放封闭原则OCP(Open－Close Principle)

**什么意思呢？**

所谓开放封闭原则就是软件实体应该对扩展开放，而对修改封闭。开放封闭原则是所有面向对象原则的核心。软件设计本身所追求的目标就是封装变化，**降低耦合，而开放封闭原则正是对这一目标的最直接体现。**

**开放封闭原则主要体现在两个方面：**

**对扩展开放**，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。

**对修改封闭**，意味着类一旦设计完成，就可以独立其工作，而不要对类尽任何修改。


**如何做到对扩展开放，对修改封闭呢？**

实现开放封闭的核心思想就是**对抽象编程**，而**不对具体编程**，**因为抽象相对稳定**。**让类依赖于固定的抽象，所以对修改就是封闭的**；而**通过面向对象的继承和多态机制，可以实现对抽象体的继承，通过覆写其方法来改变固有行为，实现新的扩展方法，所以对于扩展就是开放的。**

对于违反这一原则的类，必须通过重构来进行改善。常用于实现的设计模式主要有Template Method模式和Strategy 模式。而封装变化，是实现这一原则的重要手段，将经常变化的状态封装为一个类。

**一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的**。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，**就应当将服务端和客户端分开，公共部分抽象出来**。

#### 里式替换原则LSP(the Liskov Substitution Principle LSP)

**子类应当可以替换父类并出现在父类能够出现的任何地方**。（比如父类public，子类一定是public）比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

#### 依赖倒置原则DIP(the Dependency Inversion Principle DIP)

A.**高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象**。

B.抽象不应该依赖于具体实现，**具体实现应该依赖于抽象**。

**具体依赖抽象，上层依赖下层**。**高层模块就是调用端，底层模块就是具体实现类。（应该让底层模块定义抽象接口并且实现，让高层模块调用抽象接口，而不是直接调用实现类。）**

通俗来讲：依赖倒置原则的本质就是通过抽象（接口或抽象类）使个各类或模块的实现彼此独立，互不影响，实现模块间的松耦合。

问题描述：类A直接依赖类B，假如要将类A改为依赖类C，则必须通过修改类A的代码来达成。这种场景下，类A一般是高层模块，负责复杂的业务逻辑；类B和类C是低层模块，负责基本的原子操作；**假如修改类A，会给程序带来不必要的风险。**

解决方案：**将类A修改为依赖接口interface，类B和类C各自实现接口interface，类A通过接口interface间接与类B或者类C发生联系，则会大大降低修改类A的几率。（比如A依赖于车的轮胎，速度，牌子等接口，然后让B，C直接实现这些接口的方法，A间接通过接口与BC发生联系。）**

好处：依赖倒置的好处在小型项目中很难体现出来。但在大中型项目中可以减少需求变化引起的工作量。使并行开发更友好。

#### 接口分离原则ISP(the Interface Segregation Principle ISP)

**模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来，即面向接口编程**。**（提供接口，给其他模块调用）**

核心思想：类间的依赖关系应该建立在最小的接口上通俗来讲：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。

也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。

问题描述：类A通过接口interface依赖类B，类C通过接口interface依赖类D，如果接口interface对于类A和类C来说不是最小接口，则类B和类D必须去实现他们不需要的方法。

需注意：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情为依赖接口的类定制服务。只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。

#### 迪米特法则（Law of Demeter,简称LoD）

核心思想：类间解耦。

通俗来讲：一个类对自己依赖的类知道的越少越好。自从我们接触编程开始，就知道了软件编程的总的原则：**低耦合，高内聚**。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。

**耦合是：**

简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。

有软硬件之间的耦合，还有软件各模块之间的耦合。
耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。

耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：

* **内容耦合**：**当一个模块直接修改或操作另一个模块的数据时**，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。

**公共耦合**：**两个或两个以上的模块共同引用一个全局数据项**，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。

* **外部耦合**：一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。

* **控制耦合**：一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。

* **标记耦合**：若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。

* **数据耦合**：模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，**往往需要将某些模块的输出数据作为另一些模块的输入数据。**

* **非直接耦合**：两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。

#### 总结

耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量**使用数据耦合**，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。


**同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。**

### 一些问题

#### 面向对象和面向过程的区别？

* **面向过程**： 一种较早的编程思想，顾名思义就是该思想是站着过程的角度思考问题，强调的就是功能行为，功能的执行过程，即先后顺序，而每一个功能我们都使用函数（类似于方法）把这些步骤一步一步实现。使用的时候依次调用函数就可以了。
* **面向过程的设计**： 最小的程序单元是函数，每个函数负责完成某一个功能，用于接受输入数据，函数对输入数据进行处理，然后输出结果数据，整个软件系统由一个个的函数组成，其中作为程序入口的函数称之为主函数，主函数依次调用其他函数，普通函数之间可以相互调用，从而实现整个系统功能。 面向过程最大的问题在于随着系统的膨胀，面向过程将无法应付，最终导致系统的崩溃。为了解决这一种软件危机，我们提出面向对象思想。
* **面向过程的缺陷**： 是采用指定而下的设计模式，在设计阶段就需要考虑每一个模块应该分解成哪些子模块，每一个子模块又细分为更小的子模块，如此类推，直到将模块细化为一个个函数。
* **存在的问题**
​ 设计不够直观，与人类的思维习惯不一致 系统软件适应新差，可拓展性差，维护性低
* **面向对象**：
​ 一种基于面向过程的新编程思想，顾名思义就是该思想是站在对象的角度思考问题，我们把多个功能合理放到不同对象里，强调的是具备某些功能的对象。
具备某种功能的实体，称为对象。面向对象最小的程序单元是：类。面向对象更加符合常规的思维方式，稳定性好，可重用性强，易于开发大型软件产品，有良好的可维护性。

在软件工程上，面向对象可以使工程更加模块化，实现更低的耦合和更高的内聚。



#### 什么是方法重写

子类如果对继承的父类的方法不满意（不适合），可以自己编写继承的方法，这种方式就称为**方法的重写**。**当调用方法时会优先调用子类的方法。**

**重写要注意：**

a、返回值类型

b、方法名

c、参数类型及个数

都要与父类继承的方法相同，才叫方法的重写。

#### 重载和重写的区别

方法重载：在同一个类中处理不同数据的多个相同方法名的多态手段。

方法重写：相对继承而言，子类中对父类已经存在的方法进行区别化的修改。

#### 继承的初始化顺序

1、初始化父类再初始化子类

2、先执行初始化对象中属性，再执行构造方法中的初始化。

基于上面两点，我们就知道实例化一个子类，java程序的执行顺序是：

**父类对象属性初始化---->父类对象构造方法---->子类对象属性初始化--->子类对象构造方法**
