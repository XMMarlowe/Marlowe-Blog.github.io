---
title: Java浮点数精度问题
author: Marlowe
tags:
  - Java
  - 精度
categories: Java
abbrlink: 180
date: 2021-05-10 16:07:00
---

<!--more-->

### 一、精度丢失的原因

```java
首先我们要搞清楚下面两个问题：
(1) 十进制整数如何转化为二进制数
           算法很简单。举个例子，11表示成二进制数：
                     11/2=5 余   1
                     5/2=2   余   1
                     2/2=1   余   0
                     1/2=0   余   1
                     0结束         11二进制表示为(从下往上):1011
 
这里提一点：只要遇到除以后的结果为0了就结束了，大家想一想，所有的整数除以2是不是一定能够最终得到0。换句话说，所有的整数转变为二进制数的算法会不会无限循环下去呢？绝对不会，整数永远可以用二进制精确表示 ，但小数就不一定了。
 
(2) 十进制小数如何转化为二进制数
算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数
   0.9*2=1.8   取整数部分 1
   0.8(1.8的小数部分)*2=1.6    取整数部分 1
   0.6*2=1.2   取整数部分 1
   0.2*2=0.4   取整数部分 0
   0.4*2=0.8   取整数部分 0
   0.8*2=1.6 取整数部分 1
   0.6*2=1.2   取整数部分 0
    .........     
   0.9二进制表示为(从上往下): 1100100100100......
注意：上面的计算过程循环了，也就是说*2永远不可能消灭小数部分，这样算法将无限下去。很显然，小数的二进制表示有时是不可能精确的 。其实道理很简单，十进制系统中能不能准确表示出1/3呢？同样二进制系统也无法准确表示1/10。这也就解释了为什么浮点型减法出现了"减不尽"的精度丢失问题。
```

### 二、float存储原理

```java
众所周知、 Java 的float型在内存中占4个字节。float的32个二进制位结构如下
 
float内存存储结构
 
             4bytes      31    30    29----23    22----0        
 
             表示       实数符号位    指数符号位        指数位          有效数位
 
        其中符号位1表示正，0表示负。有效位数位24位，其中一位是实数符号位。
 
         将一个float型转化为内存存储格式的步骤为：
 
        （1）先将这个实数的绝对值化为二进制格式，注意实数的整数部分和小数部分的二进制方法在上面已经探讨过了。
     （2）将这个二进制格式实数的小数点左移或右移n位，直到小数点移动到第一个有效数字的右边。
     （3）从小数点右边第一位开始数出二十三位数字放入第22到第0位。
     （4）如果实数是正的，则在第31位放入“0”，否则放入“1”。
     （5）如果n 是左移得到的，说明指数是正的，第30位放入“1”。如果n是右移得到的或n=0，则第30位放入“0”。
     （6）如果n是左移得到的，则将n减去1后化为二进制，并在左边加“0”补足七位，放入第29到第23位。如果n是右移得到的或n=0，则将n化为二进制后在左边加“0”补足七位，再各位求反，再放入第29到第23位。
 
          举例说明： 11.9的内存存储格式
 
       (1) 将11.9化为二进制后大约是" 1011. 1110011001100110011001100..."。
 
       (2) 将小数点左移三位到第一个有效位右侧： "1. 011 11100110011001100110 "。 保证有效位数24位，右侧多余的截取（误差在这里产生了 ）。
 
       (3) 这已经有了二十四位有效数字，将最左边一位“1”去掉，得到“ 011 11100110011001100110 ”共23bit。将它放入float存储结构的第22到第0位。
 
       (4) 因为11.9是正数，因此在第31位实数符号位放入“0”。
 
       (5) 由于我们把小数点左移，因此在第30位指数符号位放入“1”。
 
       (6) 因为我们是把小数点左移3位，因此将3减去1得2，化为二进制，并补足7位得到0000010，放入第29到第23位。
 
           最后表示11.9为： 0 1 0000010 011 11100110011001100110
 
           再举一个例子：0.2356的内存存储格式
      （1）将0.2356化为二进制后大约是0.00111100010100000100100000。
      （2）将小数点右移三位得到1.11100010100000100100000。
      （3）从小数点右边数出二十三位有效数字，即11100010100000100100000放
入第22到第0位。
      （4）由于0.2356是正的，所以在第31位放入“0”。
      （5）由于我们把小数点右移了，所以在第30位放入“0”。
      （6）因为小数点被右移了3位，所以将3化为二进制，在左边补“0”补足七
位，得到0000011，各位取反，得到1111100，放入第29到第23位。
 
 
           最后表示0.2356为：0 0 1111100 11100010100000100100000
 
          将一个内存存储的float二进制格式转化为十进制的步骤：
     （1）将第22位到第0位的二进制数写出来，在最左边补一位“1”，得到二十四位有效数字。将小数点点在最左边那个“1”的右边。
     （2）取出第29到第23位所表示的值n。当30位是“0”时将n各位求反。当30位是“1”时将n增1。
     （3）将小数点左移n位（当30位是“0”时）或右移n位（当30位是“1”时），得到一个二进制表示的实数。
     （4）将这个二进制实数化为十进制，并根据第31位是“0”还是“1”加上正号或负号即可。
```

### 三、浮点类型减法运算

```java
浮点加减运算过程比定点运算过程复杂。完成浮点加减运算的操作过程大体分为四步：
 
(1) 0操作数的检查；
        如果判断两个需要加减的浮点数有一个为0，即可得知运算结果而没有必要再进行有序的一些列操作。
 
(2) 比较阶码（指数位）大小并完成对阶；
    两浮点数进行加减，首先要看两数的 指数位 是否相同，即小数点位置是否对齐。若两数 指数位 相同，表示小数点是对齐的，就可以进行尾数的加减运算。反之，若两数阶码不同，表示小数点位置没有对齐，此时必须使两数的阶码相同，这个过程叫做对阶 。
 
    如何对 阶(假设两浮点数的指数位为 Ex 和 Ey )：
    通过尾数的移位以改变 Ex 或 Ey ，使之相等。 由 于浮点表示的数多是规格化的，尾数左移会引起最高有位的丢失，造成很大误差；而尾数右移虽引起最低有效位的丢失，但造成的误差较小，因此，对阶操作规定使 尾数右移，尾数右移后使阶码作相应增加，<br>    其数值保持不变。很显然，一个增加后的阶码与另一个相等，所增加的阶码一定是小阶。因此在对阶时，总是使小阶向大阶看齐 ，即小阶的尾数向右移位 ( 相当于小数点左移 ) ，每右移一位，其阶码加 1 ，直到两数的阶码相等为止，右移的位数等于阶差 △ E 。
 
(3) 尾数（有效数位）进行加或减运算；
 
(4) 结果规格化并进行舍入处理。
```

### 四、浮点类型标识的有效数字及数值范围

1、Float：比特数为32，有效数字为6-7，数值范围为 -3.4E+38 和 3.4E+38

2、Double：比特数为64，有效数字为15-16，数值范围为-1.7E-308～1.7E+308

```java
对于单精度浮点数（float）来说，有一位符号位，指数位共8位，尾数共23位。指数能够表示的指数范围为-128~127。尾数为23位。当尾数全1时再加上小数点前面的1，指数取到最大正数127（8位，正数最大127，负数最小-128）,浮点数取得正数的最大值。
+1.111111111111111111111*2^127（1.后面23个1，由于尾数的范围1～2，其最高位总为1，故只需存取小数部分，所以小数为是23位1），约等于2*2^127=3.4*10^38。为3.4*10^38负数亦然。
 
Double的计算与此类似，double的符号位为63位，指数为62～52位，共11位。表示的范围为-1024～1023。尾数为51～0。表示的范围为+1.111111111111111111111*2^1023（1.后面52个1）为1.7*10^308。负数亦然。
```

### 五、BigDecimal替代

```java
大多数情况下，使用double和float计算的结果是准确的，但是在一些精度要求很高的系统中或者已知的小数计算得到的结果会不准确，这种问题是非常严重的。
 
《Effective Java》中提到一个原则，那就是float和double只能用来作科学计算或者是工程计算，但在商业计算中我们要用java.math.BigDecimal，通过使用BigDecimal类可以解决上述问题，java的设计者给编程人员提供了一个很有用的类BigDecimal，他可以完善float和double类无法进行精确计算的缺憾。
 
使用BigDecimal，但一定要用BigDecimal(String)构造器，而千万不要用BigDecimal(double)来构造（也不能将float或double型转换成String再来使用BigDecimal(String)来构造，因为在将float或double转换成String时精度已丢失）。例如new BigDecimal(0.1)，它将返回一个BigDecimal，也即0.1000000000000000055511151231257827021181583404541015625，正确使用BigDecimal，程序就可以打印出我们所期望的结果0.9：
Java代码 
System.out.println(new BigDecimal("2.0").subtract(new BigDecimal("1.10")));// 0.9 
 
另外，如果要比较两个浮点数的大小，要使用BigDecimal的compareTo方法。
```

### 六、BigDecimal如何解决精度问题

```java
BigDecimal的底层数据结构使什么？它是怎么保证精度的？

这曾经是一道阿里巴巴的面试题，由于在工作中使用最多的是BigDecimal的加、减、乘、除的的方法，还真没想过它的实现原理（完全是拿来主义惹的祸），乍这么一问还真有点懵。BigDecimal保证精度的解决思路其实极其的简单朴素，还是用一句话来解释：十进制整数在转化成二进制数时不会有精度问题，那么把十进制小数扩大N倍让它在整数的维度上进行计算，并保留相应的精度信息。
————————————————

源码中 scale字段记录精度信息；intCompact字段记录放大的整数信息
```

### 参考

[浮点类型计算精度不准确原因及如何规避](https://www.cnblogs.com/wangsong412/p/11798633.html)