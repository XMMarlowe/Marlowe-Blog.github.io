---
title: 研发高频算法题
author: Marlowe
tags:
  - 二叉树
  - 数组
  - 链表
  - dp
categories: 题解
abbrlink: 43602
date: 2021-04-01 17:08:20
---
牛客研发最爱考
<!--more-->

### 字符串

#### 进制转换
[题目链接](https://www.nowcoder.com/practice/2cc32b88fff94d7e8fd458b8c7b25ec1?tpId=190&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)
![20210408221854](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210408221854.png)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * 进制转换
     * @param M int整型 给定整数
     * @param N int整型 转换到的进制
     * @return string字符串
     */
    public String solve (int M, int N) {
        if(M == 0){
            return "0";
        }
        // 存储各进制转换后的字符
        String s = "0123456789ABCDEF";
        // 判断是否为负数，如果为负数，则需要添加负号
        boolean f = false;
        if(M < 0){
            f = true;
            M = -M;
        }
        StringBuilder sb = new StringBuilder();
        // 得到进制转换逆序的结果
        while(M != 0){
            sb.append(s.charAt(M%N));
            M /= N;
        }
        // 如果是负数，则添加负号
        if(f){
            sb.append("-");
        }
        return sb.reverse().toString();
    }
}
```


### 二分查找

#### 在转动过的有序数组中寻找目标值
[题目链接](https://www.nowcoder.com/practice/7cd13986c79d4d3a8d928d490db5d707?tpId=190&tqId=35352&rp=1&ru=%2Fta%2Fjob-code-high-rd&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

![20210404141152](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210404141152.png)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param A int整型一维数组 
     * @param target int整型 
     * @return int整型
     */
    public int search (int[] A, int target) {
        // 如果没有翻转，则直接二分查找
        if(A[0] < A[A.length - 1]){
            return bsearch(A,target,0,A.length - 1);
        }
        int left = 0;
        int right = A.length - 1;
        int mid;
        // 找到翻转点
        while(left <= right){
            mid = (left + right) / 2;
            if(A[mid] >= A[0]){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        // 如果要查找的值比最左边的大，则在翻转点左边二分查找
        if(target >= A[0]){
            return bsearch(A,target,0,right);
        }else{// 反之
            return bsearch(A,target,left,A.length - 1);
        }
    }
    
    // 二分查找标准代码
    public int bsearch(int[] A,int target,int left, int right){
        int mid;
        while(left <= right){
            mid = (left + right) / 2;
            if(target == A[mid]){
                return mid;
            }else if(target > A[mid]){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

#### 搜索旋转排序数组
[题目链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

![20210407145332](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210407145332.png)

代码如下：
```java
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if(nums == null || n == 0){
            return -1;
        }
        if(n == 1){
            return nums[0] == target ? 0 : -1;
        }
        int left = 0;
        int right = n - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == target){
                return mid;
            }
            // 左边是有序的
            if(nums[0] <= nums[mid]){
                if(nums[mid] > target && target >= nums[0]){
                    right = mid - 1;
                }else{
                    left = mid + 1;
                }
            }else{
                // 右边是有序的
                if(nums[mid] < target && target <= nums[n-1]){
                    left = mid + 1;
                }else{
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

#### 搜索旋转排序数组 II
[题目链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)
![20210407150627](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210407150627.png)

代码如下：
```java
class Solution {
    public boolean search(int[] nums, int target) {
        if(nums == null || nums.length == 0){
            return false;
        }
        int start = 0;
        int end = nums.length - 1;
        while(start <= end){
            int mid = start + (end - start) / 2;
            if(nums[mid] == target){
                return true;
            }
            // 去掉重复的
            if(nums[start] == nums[mid]){
                start++;
                continue;
            }
            // 左边部分有序
            if(nums[start] < nums[mid]){
                // target在左边
                if(nums[mid] > target && nums[start] <= target){
                    end = mid - 1;
                }else{
                    start = mid + 1;
                }
            }else{
                // target在右边
                if(nums[mid] < target && target <= nums[end]){
                    start = mid + 1;
                }else{
                    end = mid - 1;
                }
            }
        }
        return false;
    }
}
```

#### 寻找旋转排序数组中的最小值 II
[题目链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)
![20210409210819](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210409210819.png)

代码如下：
```java
class Solution {
    public int findMin(int[] nums) {
        int left= 0;
        int right = nums.length - 1;
        while(left <= right){
            int mid = left + (right - left) / 2;
            if(nums[mid] == nums[right]){
                right--;
            }else if(nums[mid] < nums[right]){
                // 中间值比最右边的值小，而中间这个值可能是最小值，所以右指针为mid，不能为mid - 1
                right = mid;
            }else{
                // 中间值比最右边的值大，因此左指针为mid + 1
                left = mid + 1;
            }
        }
        return nums[left];
    }
}
```



### 链表


#### 两个链表生成相加链表
![20210401215738](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401215738.png)

代码如下:
```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        // 将两个链表反转
        ListNode p1 = reverse(head1);
        ListNode p2 = reverse(head2);
        // 定义结果链表
        ListNode res = new ListNode(-1);
        ListNode curr = res;
        // 进位
        int carry = 0;
        while(p1 != null || p2 != null){
            int sum = 0;
            if(p1 != null){
                sum += p1.val;
                p1 = p1.next;
            }
            if(p2 != null){
                sum += p2.val;
                p2 = p2.next;
            }
            // 低位+进位
            sum += carry;
            
            curr.next = new ListNode(sum % 10);
            // 从新计算进位
            carry = sum / 10;
            curr = curr.next;
        }
        // 如果有进位，直接加到结果链表尾部
        if(carry > 0){
            curr.next = new ListNode(carry);
        }
        // 将结果链表反转
        return reverse(res.next);
        
    }
    // 翻转链表
    public ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode next = null;
        while(head != null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```

#### 合并k个已排序的链表
[题目链接](https://www.nowcoder.com/practice/65cfde9e5b9b4cf2b6bafa5f3ef33fa6?tpId=190&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

![20210406162347](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210406162347.png)

代码如下：
```java
import java.util.*;
public class Solution {
    public ListNode mergeKLists(ArrayList<ListNode> lists) {
        if(lists == null || lists.size() == 0){
            return null;
        }
        return mergeKList(lists,0,lists.size() - 1);
    }
    
    public ListNode mergeKList(ArrayList<ListNode> lists,int low, int high) {
        // 左右相等说明不能再分
        if(low >= high){
            return lists.get(low);
        }
        // 计算mid
        int mid = low + (high - low) / 2;
        ListNode l1 = mergeKList(lists,low,mid);
        ListNode l2 = mergeKList(lists,mid + 1,high);
        return merge(l1,l2);
    }
    
    // 合并两个有序链表
    public ListNode merge(ListNode node1,ListNode node2){
        ListNode node = new ListNode(-1);
        ListNode tmp = node;
        while(node1!=null && node2!=null){
            if(node1.val <= node2.val){
                tmp.next = node1;
                node1 = node1.next;
            }else{
                tmp.next = node2;
                node2 = node2.next;
            }
            tmp = tmp.next;
        }
        tmp.next = node1!=null?node1:node2;
        return node.next;
    }
}
```

#### 单链表的排序
[题目链接](https://www.nowcoder.com/practice/f23604257af94d939848729b1a5cda08?tpId=190&tqId=35599&rp=1&ru=%2Fta%2Fjob-code-high-rd&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

![20210407151743](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210407151743.png)

代码如下：
```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head ListNode类 the head node
     * @return ListNode类
     */
    public ListNode sortInList (ListNode head) {
        if(head == null || head.next == null){
            return head;
        }
        // 使用快慢指针找到链表中间部分
        ListNode slow = head;
        ListNode fast = head.next;
        while(fast != null && fast.next != null){
            slow = slow.next;
            fast = fast.next.next;
        }
        // 截取第二部分链表
        ListNode newList = slow.next;
        slow.next = null;
        // 递归继续分割两个链表
        ListNode left = sortInList(head);
        ListNode right = sortInList(newList);
        // 合并两个有序链表
        ListNode dummy = new ListNode(-1);
        ListNode res = dummy;
        while(left != null && right != null){
            if(left.val < right.val){
                res.next = left;
                left = left.next;
            }else{
                res.next = right;
                right = right.next;
            }
            res = res.next;
        }
        res.next = left == null? right : left;
        return dummy.next;
    }
}
```


### 大数加法
![20210401192250](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401192250.png)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param s string字符串 表示第一个整数
     * @param t string字符串 表示第二个整数
     * @return string字符串
     */
    public String solve (String s, String t) {
        // write code here
        int i = s.length() - 1;
        int j = t.length() - 1;
        int carry = 0;
        StringBuilder sb = new StringBuilder();
        while(i >= 0 || j >= 0 || carry != 0){
            int x = i < 0 ? 0 : s.charAt(i--) - '0';
            int y = j < 0 ? 0 : t.charAt(j--) - '0';
            int sum = x + y + carry;
            sb.append(sum % 10);
            carry = sum / 10;
        }
        return sb.reverse().toString();
    }
}
```

### 二叉树
#### 重建二叉树

![20210401190107](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401190107.png)

代码如下：
```java
import java.util.*;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        Map<Integer,Integer> map = new HashMap();
        for(int i = 0; i < in.length; i++){
            map.put(in[i],i);
        }
        return dfs(0,pre.length - 1,0,in.length - 1,pre,in,map);
    }
    
    public TreeNode dfs(int pl,int pr,int il,int ir,int[] pre,int[] in,Map<Integer,Integer> map){
        if(pl > pr){
            return null;
        }
        // 根据先序遍历获得根节点
        int k = map.get(pre[pl]);
        TreeNode root = new TreeNode(pre[pl]);
        // 递归构造左子树
        root.left = dfs(pl + 1,pl  + k -il,il,k-1,pre,in,map);
        // 递归构造右子树
        root.right = dfs(pl + k- il + 1,pr,k+1,ir,pre,in,map);
        return root;
    }
}
```
#### 在二叉树中找到两个节点的最近公共祖先
![20210401190918](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401190918.png)

以下图片来自于牛客`￥ABCDEF`题解
![图解](https://uploadfiles.nowcoder.com/images/20201227/9980465_1609082550672/DBDA4575BF1F94AAC70E96788DE74D5E)
代码如下：
```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        return dfs(root,o1,o2).val;
    }
    
    public TreeNode dfs(TreeNode root ,int o1,int o2){
        // 如果当前节点为空，或者当前节点等于o1或者等于o2就返回值给父亲节点
        if(root == null || root.val == o1 || root.val == o2){
            return root;
        }
        // 递归遍历左子树
        TreeNode left = dfs(root.left,o1,o2);
        // 递归遍历右子树
        TreeNode right = dfs(root.right,o1,o2);
        // 如果left、right都不为空，那么代表o1、o2在root的两侧，所以root为他们的公共祖先
        if(left != null && right != null){
            return root;
        }
        // 如果left、right有一个为空，那么就返回不为空的那一个
        return left == null? right : left;
    }
}
```


#### 对称的二叉树
[题目链接](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)
![20210401223309](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401223309.png)

代码如下：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root == null ? true : recur(root.left,root.right);
    }

    public boolean recur(TreeNode A,TreeNode B){
        // 左右子树都为空，则树是对称的
        if(A == null && B == null){
            return true;
        }
        // 只有一边为空，且值不相等，则不对称
        if(A == null || B == null || A.val != B.val){
            return false;
        }
        // 递归判断左右子树，如果都对称，则树对称
        return recur(A.left,B.right) && recur(A.right,B.left);
    }
}
```

#### 二叉树的右视图
[题目链接](https://leetcode-cn.com/problems/binary-tree-right-side-view/)
![20210406200218](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210406200218.png)

代码如下：
```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList();
        if(root == null){
            return res;
        }
        Queue<TreeNode> q = new LinkedList();
        q.offer(root);
        while(!q.isEmpty()){
            int size = q.size();
            for(int i = 0; i < size; i++){
                TreeNode node = q.poll();
                if(node.left != null){
                    q.offer(node.left);
                }
                if(node.right != null){
                    q.offer(node.right);
                }
                // 将每一层的最后一个加入结果集,即为右视图
                if(i == size - 1){
                    res.add(node.val);
                }
            }
        }
        return res;
    }
}
```


### 动态规划
#### 子数组的最大累加和问题
![20210401191428](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401191428.png)

以下图片来自于牛客`￥ABCDEF`题解
![图解](https://uploadfiles.nowcoder.com/images/20210121/9980465_1611235762465/CB65BF8E78B2545F56C8BBDC8D640766)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * max sum of the subarray
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxsumofSubarray (int[] arr) {
        // write code here
        //dp[i]代表到第i位的时侯,以arr[i]结尾的连续子数组最大累加和
        int[] dp = new int[arr.length];
        dp[0] = arr[0];
        int res = arr[0];
        for(int i = 1; i< arr.length; i++){
            // 如果前面的子数组和大于0，则更新当前位置
            if(dp[i-1] > 0){
                dp[i] = dp[i-1] + arr[i];
            }else{ // 否则，更新当前dp值为当前数组值
                dp[i] = arr[i];
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

#### 最长递增子序列
[1. 题目链接](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=190&tqId=35211&rp=1&ru=%2Fta%2Fjob-code-high-rd&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

![20210401204605](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401204605.png)

代码如下:
```java

```

[2.题目链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
![20210401214846](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401214846.png)

代码如下：
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        // dp数组表示以nums[1]结尾的“最长上升子序列”的长度
        int[] dp = new int[n];
        // 初始化dp数组为1
        Arrays.fill(dp,1);
        for(int i = 1; i < n; i++){
            // 下标为i以前上升子序列
            for(int j= 0; j < i; j++){
                if(nums[j] < nums[i]){
                    // 根据状态转换图更新最长上升子序列的长度
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }
        }
        // 找到最大值
        int max = 0;
        for(int i = 0; i < n; i++){
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```

#### 最长公共子序列

[题目链接](https://leetcode-cn.com/problems/longest-common-subsequence/)
![20210403133829](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210403133829.png)

代码如下：
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][]  dp = new int[m+1][n+1];
        for(int i = 1; i <= m; i++){
            char ch1 = text1.charAt(i-1);
            for(int j = 1; j <= n; j++){
                char ch2 = text2.charAt(j-1);
                if(ch1 == ch2){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```

#### 买卖股票的最佳时机
[题目链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
![20210404205827](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210404205827.png)

```java
import java.util.*;


public class Solution {
    /**
     * 
     * @param prices int整型一维数组 
     * @return int整型
     */
    public int maxProfit (int[] prices) {
        int min = Integer.MAX_VALUE;
        int maxProfit = 0;
        for(int i = 0; i < prices.length; i++){
            // 记录历史最低价
            if(prices[i] < min){
                min = prices[i];
            }else if(prices[i] - min > maxProfit){
                // 更新最大收益
                maxProfit = prices[i] - min;
            }
        }
        return maxProfit;
    }
}
```

#### 买卖股票的最佳时机 II
[题目链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)

![20210404210444](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210404210444.png)

代码如下：
```java

```


#### 编辑距离
[题目链接](https://www.nowcoder.com/practice/05fed41805ae4394ab6607d0d745c8e4?tpId=190&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

![20210409220146](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210409220146.png)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * min edit cost
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @param ic int整型 insert cost
     * @param dc int整型 delete cost
     * @param rc int整型 replace cost
     * @return int整型
     */
    public int minEditCost (String str1, String str2, int ic, int dc, int rc) {
        int m = str1.length();
        int n = str2.length();
        int[][] dp = new int[m+1][n+1];
        // 初始化第一行
        for(int j = 1; j <= n; j++){
            dp[0][j] = j * ic;
        }
        // 初始化第一列
        for(int i = 1; i <= m; i++){
            dp[i][0] = i * dc;
        }
        for(int i = 1; i <= m; i++){
            for(int j = 1; j <= n; j++){
                if(str1.charAt(i-1) == str2.charAt(j-1)){
                    dp[i][j] = dp[i-1][j-1];
                }else{
                    // 将i个字符串转变为前j-1个字符串在插入第j个字符
                    int insert = dp[i][j-1] + ic;
                    // 将i-1个字符串转换为前j个字符串删除第i个字符
                    int delete = dp[i-1][j] + dc;
                    int replace = dp[i-1][j-1] + rc;
                    dp[i][j] = Math.min(Math.min(insert,delete),replace);
                }
            }
        }
        return dp[m][n];
    }
}
```

### 中心扩散法

#### 最长回文子串

![20210401190434](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401190434.png)

代码如下：
```java
import java.util.*;

public class Solution {
    public int getLongestPalindrome(String A, int n) {
        int len = A.length();
        if(len < 2){
            return A.length();
        }
        int max = 0;
        for(int i = 0; i < len - 1; i++){
            // 回文类型为奇数型
            String s1 = helper(A,i,i);
            // 回文类型为偶数型
            String s2 = helper(A,i,i+1);
            // 求出最长的回文串
            String s3 = s1.length() > s2.length()? s1: s2;
            if(max < s3.length()){
                max = s3.length();
            }
        }
        return max;
    }
    
    public String helper(String s, int left, int right){
        int len = s.length();
        int i = left;
        int j = right;
        // 从中间向两边扩散
        while(i >= 0 && j < len){
            if(s.charAt(i) == s.charAt(j)){
                i--;
                j++;
            }else{
                break;
            }
        }
        // 截取回文串
        return s.substring(i+1,j);
    } 
}
```
### 单调栈

#### 直方图的水量
[题目链接](https://leetcode-cn.com/problems/volume-of-histogram-lcci/)
![20210402140411](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210402140411.png)

代码如下(双指针)：
```java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int ans = 0;
        int leftMax = 0;
        int rightMax = 0;
        while(left < right){
            // 更新左边的最大值
            leftMax = Math.max(leftMax,height[left]);
            // 更新右边的最大值
            rightMax = Math.max(rightMax,height[right]);
            if(height[left] < height[right]){
                // 用左边的最大值减去当前高度
                ans += leftMax - height[left];
                left++;
            }else{
                // 用右边的最大值减去当前高度
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
}
```

代码如下(单调栈):
```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList();
        for(int i = 0; i < height.length; i++){
            while(!stack.isEmpty() && height[i] > height[stack.peek()] ){
                int top = stack.pop();
                if(stack.isEmpty()){
                    break;
                }
                int left = stack.peek();
                int width = i - left - 1;
                int currHeight = Math.min(height[i],height[left]) - height[top];
                ans += currHeight * width;
            }
            stack.push(i);
        }
        return ans;
    }
}
```

#### 柱状图中最大的矩形
[题目链接](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
![20210402144908](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210402144908.png)


```java
public int largestRectangleArea(int[] heights) {
        // 初始化最终结果为0
        int res = 0;
        Stack<Integer> stack = new Stack<>();

        // 将给定的原数组左右各添加一个元素0
        int[] newHeights = new int[heights.length + 2];
        newHeights[0] = 0;
        newHeights[newHeights.length-1] = 0;
        for (int i = 1; i < heights.length + 1; i++) {
            newHeights[i] = heights[i - 1];
        }

        // 开始遍历
        for (int i = 0; i < newHeights.length; i++) {
            // 如果栈不为空且当前考察的元素值小于栈顶元素值，
            // 则表示以栈顶元素值为高的矩形面积可以确定
            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {
                // 弹出栈顶元素
                int cur = stack.pop();
                // 获取栈顶元素对应的高
                int curHeight = newHeights[cur];
                // 栈顶元素弹出后，新的栈顶元素就是其左侧边界
                int leftIndex = stack.peek();
                // 右侧边界是当前考察的索引
                int rightIndex = i;
                // 计算矩形宽度
                int curWidth = rightIndex - leftIndex - 1;
                // 计算面积
                res = Math.max(res, curWidth * curHeight);
            }   
            // 当前考察索引入栈
            stack.push(i);
        }
        return res;
    }
```


### 栈

#### 设计getMin功能的栈

[题目链接](https://www.nowcoder.com/practice/c623426af02d4c189f92f2a99647bd34?tpId=190&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

![20210404203630](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210404203630.png)

代码如下：
```java
import java.util.*;


public class Solution {
    public Deque<Integer> s = new LinkedList();
    public Deque<Integer> min_s = new LinkedList();
    
    /**
     * return a array which include all ans for op3
     * @param op int整型二维数组 operator
     * @return int整型一维数组
     */
    public int[] getMinStack (int[][] op) {
        List<Integer> res = new ArrayList();
        for(int i = 0; i < op.length; i++){
            if(op[i][0] == 1){
                Push(op[i][1]);
            }else if(op[i][0] == 2){
                Pop();
            }else{
                res.add(getMin());
            }
        }
        int[] ans = new int[res.size()];
        for(int  i = 0; i < ans.length; i++){
            ans[i] = res.get(i);
        }
        return ans;
    }
    
    
    // 如果最小栈为空，或者栈顶元素大于x，则加入最小栈
    public void Push(int x){
        s.push(x);
        if(min_s.isEmpty() || min_s.peek() > x){
            min_s.push(x);
        }
        
    }
    // 如果最小栈栈顶元素和栈s中要出栈的元素相等，那么也需要出栈
    public void Pop(){
        if(!s.isEmpty()){
            if(s.peek().equals(min_s.peek())){
                min_s.pop();
            }
            s.pop();
        }
    }
    // 获得最小栈栈顶元素
    public int getMin(){
        return min_s.peek();
    }
}
```


### 回溯

#### 字符串的排列
[题目链接](https://www.nowcoder.com/practice/fe6b651b66ae47d7acce78ffdd9a96c7?tpId=190&tags=&title=&diffculty=0&judgeStatus=0&rp=1&tab=answerKey)

![20210406192459](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210406192459.png)

代码入下：
```java
import java.util.*;
public class Solution {
    public ArrayList<String> Permutation(String str) {
        int len = str.length();
        char[] strs = str.toCharArray();
        // 对字符数组排序
        Arrays.sort(strs);
        ArrayList<String> res = new ArrayList();
        // 存放路径
        Deque<Character> path = new ArrayDeque();
        // 保存该字符是否用过
        boolean[] used = new boolean[len];
        // 深度有限遍历求得所有结果集
        dfs(strs,len,0,used,res,path);
        return res;
    }
    
    public void dfs(char[] strs,int len,int depth,boolean[] used,ArrayList<String> res,Deque<Character> path){
        // 如果到达最深的一层
        if(len == depth){
            // 封装结果
            StringBuilder sb = new StringBuilder();
            for(char ch : path){
                sb.append(ch);
            }
            res.add(new String(sb));
            return;
        }
        for(int i = 0; i < len; i++){
            // 判断当前字符是否用过
            if(used[i]){
                continue;
            }
            // 因为有重复元素，所以在下一层碰到相同元素将会使结果重复，相对于全排列，进一步剪枝
            if(i > 0 && strs[i] == strs[i-1] && !used[i-1]){
                continue;
            }
            // 回溯算法经典步骤
            // 先将当前字符加入栈，并将使用过的元素标记为true
            path.addLast(strs[i]);
            used[i] = true;
            dfs(strs,len,depth + 1,used,res,path);
            // 回到之前的状态
            path.removeLast();
            used[i] = false;
        }
    }
}
```

### 全排列 II
[题目链接](https://leetcode-cn.com/problems/permutations-ii/)

![20210406192852](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210406192852.png)

代码如下：
```java
class Solution {
    public List<List<Integer>> permuteUnique(int[] nums) {
        // 数组长度
        int len = nums.length;
        Arrays.sort(nums);
        // 结果集
        List<List<Integer>> res = new ArrayList();
        // 双端队列，保存临时路径
        Deque<Integer> path = new ArrayDeque();
        // 布尔数组，保存改数字是否使用过
        boolean[] used = new boolean[len];
        // 深度优先遍历求所有结果集
        dfs(nums,len,0,used,path,res);
        return res;
    }

    public void dfs(int[] nums,int len,int depth,boolean[] used,Deque<Integer> path,List<List<Integer>> res){
        // 如果到达最深的一层
        if(depth == len){
            // 将当前路径加入结果集
            res.add(new ArrayList(path));
            return;
        }

        for(int i = 0 ; i < len; i++){
            // 判断当前数字是否用过
            if(used[i]){
                continue;
            }
            // 因为有重复元素，所以在下一层碰到相同元素将会使结果重复，相对于全排列，进一步剪枝
            if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) {
                continue;
            }
            // 回溯算法经典步骤
            // 先将当前数字加入栈，并将使用过的元素标记为true
            path.addLast(nums[i]);
            used[i] = true;
            dfs(nums,len,depth + 1,used,path,res);
            // 回到之前的状态
            path.removeLast();
            used[i] = false;
        }
    }
}
```

