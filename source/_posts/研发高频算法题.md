---
title: 研发高频算法题
author: Marlowe
tags:
  - 二叉树
  - 数组
  - 链表
  - dp
categories: 题解
abbrlink: 43602
date: 2021-04-01 17:08:20
---

<!--more-->

### 字符串

### 链表

#### 两个链表生成相加链表
![20210401215738](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401215738.png)

代码如下:
```java
import java.util.*;

/*
 * public class ListNode {
 *   int val;
 *   ListNode next = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param head1 ListNode类 
     * @param head2 ListNode类 
     * @return ListNode类
     */
    public ListNode addInList (ListNode head1, ListNode head2) {
        // write code here
        // 将两个链表反转
        ListNode p1 = reverse(head1);
        ListNode p2 = reverse(head2);
        // 定义结果链表
        ListNode res = new ListNode(-1);
        ListNode curr = res;
        // 进位
        int carry = 0;
        while(p1 != null || p2 != null){
            int sum = 0;
            if(p1 != null){
                sum += p1.val;
                p1 = p1.next;
            }
            if(p2 != null){
                sum += p2.val;
                p2 = p2.next;
            }
            // 低位+进位
            sum += carry;
            
            curr.next = new ListNode(sum % 10);
            // 从新计算进位
            carry = sum / 10;
            curr = curr.next;
        }
        // 如果有进位，直接加到结果链表尾部
        if(carry > 0){
            curr.next = new ListNode(carry);
        }
        // 将结果链表反转
        return reverse(res.next);
        
    }
    // 翻转链表
    public ListNode reverse(ListNode head){
        ListNode pre = null;
        ListNode next = null;
        while(head != null){
            next = head.next;
            head.next = pre;
            pre = head;
            head = next;
        }
        return pre;
    }
}
```



### 大数加法
![20210401192250](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401192250.png)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     * 计算两个数之和
     * @param s string字符串 表示第一个整数
     * @param t string字符串 表示第二个整数
     * @return string字符串
     */
    public String solve (String s, String t) {
        // write code here
        int i = s.length() - 1;
        int j = t.length() - 1;
        int carry = 0;
        StringBuilder sb = new StringBuilder();
        while(i >= 0 || j >= 0 || carry != 0){
            int x = i < 0 ? 0 : s.charAt(i--) - '0';
            int y = j < 0 ? 0 : t.charAt(j--) - '0';
            int sum = x + y + carry;
            sb.append(sum % 10);
            carry = sum / 10;
        }
        return sb.reverse().toString();
    }
}
```

### 二叉树
#### 重建二叉树

![20210401190107](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401190107.png)

代码如下：
```java
import java.util.*;
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        Map<Integer,Integer> map = new HashMap();
        for(int i = 0; i < in.length; i++){
            map.put(in[i],i);
        }
        return dfs(0,pre.length - 1,0,in.length - 1,pre,in,map);
    }
    
    public TreeNode dfs(int pl,int pr,int il,int ir,int[] pre,int[] in,Map<Integer,Integer> map){
        if(pl > pr){
            return null;
        }
        // 根据先序遍历获得根节点
        int k = map.get(pre[pl]);
        TreeNode root = new TreeNode(pre[pl]);
        // 递归构造左子树
        root.left = dfs(pl + 1,pl  + k -il,il,k-1,pre,in,map);
        // 递归构造右子树
        root.right = dfs(pl + k- il + 1,pr,k+1,ir,pre,in,map);
        return root;
    }
}
```
#### 在二叉树中找到两个节点的最近公共祖先
![20210401190918](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401190918.png)

以下图片来自于牛客`￥ABCDEF`题解
![图解](https://uploadfiles.nowcoder.com/images/20201227/9980465_1609082550672/DBDA4575BF1F94AAC70E96788DE74D5E)
代码如下：
```java
import java.util.*;

/*
 * public class TreeNode {
 *   int val = 0;
 *   TreeNode left = null;
 *   TreeNode right = null;
 * }
 */

public class Solution {
    /**
     * 
     * @param root TreeNode类 
     * @param o1 int整型 
     * @param o2 int整型 
     * @return int整型
     */
    public int lowestCommonAncestor (TreeNode root, int o1, int o2) {
        // write code here
        return dfs(root,o1,o2).val;
    }
    
    public TreeNode dfs(TreeNode root ,int o1,int o2){
        // 如果当前节点为空，或者当前节点等于o1或者等于o2就返回值给父亲节点
        if(root == null || root.val == o1 || root.val == o2){
            return root;
        }
        // 递归遍历左子树
        TreeNode left = dfs(root.left,o1,o2);
        // 递归遍历右子树
        TreeNode right = dfs(root.right,o1,o2);
        // 如果left、right都不为空，那么代表o1、o2在root的两侧，所以root为他们的公共祖先
        if(left != null && right != null){
            return root;
        }
        // 如果left、right有一个为空，那么就返回不为空的那一个
        return left == null? right : left;
    }
}
```


#### 对称的二叉树
[题目链接](https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof/)
![20210401223309](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401223309.png)

代码如下：
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return root == null ? true : recur(root.left,root.right);
    }

    public boolean recur(TreeNode A,TreeNode B){
        // 左右子树都为空，则树是对称的
        if(A == null && B == null){
            return true;
        }
        // 只有一边为空，且值不相等，则不对称
        if(A == null || B == null || A.val != B.val){
            return false;
        }
        // 递归判断左右子树，如果都对称，则树对称
        return recur(A.left,B.right) && recur(A.right,B.left);
    }
}
```


### 动态规划
#### 子数组的最大累加和问题
![20210401191428](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401191428.png)

以下图片来自于牛客`￥ABCDEF`题解
![图解](https://uploadfiles.nowcoder.com/images/20210121/9980465_1611235762465/CB65BF8E78B2545F56C8BBDC8D640766)

代码如下：
```java
import java.util.*;


public class Solution {
    /**
     * max sum of the subarray
     * @param arr int整型一维数组 the array
     * @return int整型
     */
    public int maxsumofSubarray (int[] arr) {
        // write code here
        //dp[i]代表到第i位的时侯,以arr[i]结尾的连续子数组最大累加和
        int[] dp = new int[arr.length];
        dp[0] = arr[0];
        int res = arr[0];
        for(int i = 1; i< arr.length; i++){
            // 如果前面的子数组和大于0，则更新当前位置
            if(dp[i-1] > 0){
                dp[i] = dp[i-1] + arr[i];
            }else{ // 否则，更新当前dp值为当前数组值
                dp[i] = arr[i];
            }
            res = Math.max(res,dp[i]);
        }
        return res;
    }
}
```

#### 最长递增子序列
[1. 题目链接](https://www.nowcoder.com/practice/9cf027bf54714ad889d4f30ff0ae5481?tpId=190&tqId=35211&rp=1&ru=%2Fta%2Fjob-code-high-rd&qru=%2Fta%2Fjob-code-high-rd%2Fquestion-ranking&tab=answerKey)

![20210401204605](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401204605.png)

代码如下:
```java

```

[2.题目链接](https://leetcode-cn.com/problems/longest-increasing-subsequence/)
![20210401214846](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401214846.png)

代码如下：
```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int n = nums.length;
        // dp数组表示以nums[1]结尾的“最长上升子序列”的长度
        int[] dp = new int[n];
        // 初始化dp数组为1
        Arrays.fill(dp,1);
        for(int i = 1; i < n; i++){
            // 下标为i以前上升子序列
            for(int j= 0; j < i; j++){
                if(nums[j] < nums[i]){
                    // 根据状态转换图更新最长上升子序列的长度
                    dp[i] = Math.max(dp[i],dp[j] + 1);
                }
            }
        }
        // 找到最大值
        int max = 0;
        for(int i = 0; i < n; i++){
            max = Math.max(max,dp[i]);
        }
        return max;
    }
}
```

#### 最长公共子序列

[题目链接](https://leetcode-cn.com/problems/longest-common-subsequence/)
![20210403133829](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210403133829.png)

代码如下：
```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length();
        int n = text2.length();
        int[][]  dp = new int[m+1][n+1];
        for(int i = 1; i <= m; i++){
            char ch1 = text1.charAt(i-1);
            for(int j = 1; j <= n; j++){
                char ch2 = text2.charAt(j-1);
                if(ch1 == ch2){
                    dp[i][j] = dp[i-1][j-1] + 1;
                }else{
                    dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[m][n];
    }
}
```


### 中心扩散法

#### 最长回文子串

![20210401190434](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210401190434.png)

代码如下：
```java
import java.util.*;

public class Solution {
    public int getLongestPalindrome(String A, int n) {
        int len = A.length();
        if(len < 2){
            return A.length();
        }
        int max = 0;
        for(int i = 0; i < len - 1; i++){
            // 回文类型为奇数型
            String s1 = helper(A,i,i);
            // 回文类型为偶数型
            String s2 = helper(A,i,i+1);
            // 求出最长的回文串
            String s3 = s1.length() > s2.length()? s1: s2;
            if(max < s3.length()){
                max = s3.length();
            }
        }
        return max;
    }
    
    public String helper(String s, int left, int right){
        int len = s.length();
        int i = left;
        int j = right;
        // 从中间向两边扩散
        while(i >= 0 && j < len){
            if(s.charAt(i) == s.charAt(j)){
                i--;
                j++;
            }else{
                break;
            }
        }
        // 截取回文串
        return s.substring(i+1,j);
    } 
}
```
### 单调栈

#### 直方图的水量
[题目链接](https://leetcode-cn.com/problems/volume-of-histogram-lcci/)
![20210402140411](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210402140411.png)

代码如下(双指针)：
```java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int ans = 0;
        int leftMax = 0;
        int rightMax = 0;
        while(left < right){
            // 更新左边的最大值
            leftMax = Math.max(leftMax,height[left]);
            // 更新右边的最大值
            rightMax = Math.max(rightMax,height[right]);
            if(height[left] < height[right]){
                // 用左边的最大值减去当前高度
                ans += leftMax - height[left];
                left++;
            }else{
                // 用右边的最大值减去当前高度
                ans += rightMax - height[right];
                right--;
            }
        }
        return ans;
    }
}
```

代码如下(单调栈):
```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList();
        for(int i = 0; i < height.length; i++){
            while(!stack.isEmpty() && height[i] > height[stack.peek()] ){
                int top = stack.pop();
                if(stack.isEmpty()){
                    break;
                }
                int left = stack.peek();
                int width = i - left - 1;
                int currHeight = Math.min(height[i],height[left]) - height[top];
                ans += currHeight * width;
            }
            stack.push(i);
        }
        return ans;
    }
}
```

#### 柱状图中最大的矩形
[题目链接](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
![20210402144908](http://marlowe.oss-cn-beijing.aliyuncs.com/img/20210402144908.png)


```java
public int largestRectangleArea(int[] heights) {
        // 初始化最终结果为0
        int res = 0;
        Stack<Integer> stack = new Stack<>();

        // 将给定的原数组左右各添加一个元素0
        int[] newHeights = new int[heights.length + 2];
        newHeights[0] = 0;
        newHeights[newHeights.length-1] = 0;
        for (int i = 1; i < heights.length + 1; i++) {
            newHeights[i] = heights[i - 1];
        }

        // 开始遍历
        for (int i = 0; i < newHeights.length; i++) {
            // 如果栈不为空且当前考察的元素值小于栈顶元素值，
            // 则表示以栈顶元素值为高的矩形面积可以确定
            while (!stack.isEmpty() && newHeights[i] < newHeights[stack.peek()]) {
                // 弹出栈顶元素
                int cur = stack.pop();
                // 获取栈顶元素对应的高
                int curHeight = newHeights[cur];
                // 栈顶元素弹出后，新的栈顶元素就是其左侧边界
                int leftIndex = stack.peek();
                // 右侧边界是当前考察的索引
                int rightIndex = i;
                // 计算矩形宽度
                int curWidth = rightIndex - leftIndex - 1;
                // 计算面积
                res = Math.max(res, curWidth * curHeight);
            }   
            // 当前考察索引入栈
            stack.push(i);
        }
        return res;
    }
```





