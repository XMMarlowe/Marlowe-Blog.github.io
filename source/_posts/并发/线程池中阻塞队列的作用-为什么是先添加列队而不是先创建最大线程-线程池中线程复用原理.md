---
title: 线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?线程池中线程复用原理
author: Marlowe
tags: 线程
categories: 并发
abbrlink: 50789
date: 2021-03-11 14:35:10
---
<!--more-->
### 线程池中阻塞队列的作用?

一般的队列只能保证作为一个有限长度的缓冲区,如果超出了缓冲长度,就无法保留当前的任务了,阻塞队列通过阻塞可以保留住当前想要继续入队的任务。阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程,使得线程进入wait状态,释放cpu资源。阻塞队列自带阻塞和唤醒的功能,不需要额外处理,无任务执行时,线程池利用阻塞队列的take方法挂起,从而维持核心线程的存活、不至于一直占用cpu资源

### 为什么是先添加列队而不是先创建最大线程?

在创建新线程的时候,是要获取全局锁的,这个时候其它的就得阻塞,影响了整体效率。

就好比一个饭店里面有10个(core)正式工的名额,最多招10个正式工,要是任务超过正式工人数(task>core)的情况下,工厂领导(线程池)不是首先扩招工人,还是这10人,但是任务可以稍微积压一下,即先放到队列去(代价低) 。10个正式工慢慢干,迟早会千完的,要是任务还在继续增加,超过正式工的加班忍耐极限了(队列满了) ,就的招外包帮忙了(注意是临时工)要是正式工加上外包还是不能完成任务,那新来的任务就会被领导拒绝了(线程池的拒绝策略)

 
### 线程池中线程复用原理

线程池将线程和任务进行解耦,线程是线程,任务是任务,**摆脱了之前通过Thread创建线程时的一个线程必须对应一个任务的限制。**

在线程池中,同一个线程可以从阻塞队列中不断获取新任务来执行,其核心原理在于**线程池对Thread进行了封装,并不是每次执行任务都会调用Thread.start（)来创建新线程,** 而是让每个线程去执行一个"循环任务",在这个"循环任务"中不停检查是否有任务需要被执行,如果有则直接执行,也就是调用任务中的run方法,**将run方法当成一个普通的方法执行,通过这种方式只使用固定的线程就将所有任务的run方法串联起来。**


### 参考
[线程池中阻塞队列的作用?为什么是先添加列队而不是先创建最大线程?线程池中线程复用原理](https://www.cnblogs.com/yuyyg/p/14508985.html)