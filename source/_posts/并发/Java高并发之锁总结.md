---
title: Java高并发之锁总结
author: Marlowe
tags:
  - Java
  - 锁
categories: 并发
abbrlink: 47470
date: 2021-04-11 21:37:12
---

<!--more-->

### 锁的分类

#### 1. 乐观锁与悲观锁

* **乐观锁**

1. 对共享数据进行访问时，乐观锁**总是认为不会有其他线程修改数据修改数据。**
2. 于是直接执行操作，只是在**更新时检查数据是否已经被其他线程修改。**
3. 如果没有被修改，则操作执行成功；否则，添加其他补偿措施。
4. 常见的补偿措施是不断尝试，直到成功。

* Java中的**非阻塞同步**都是采用这种**乐观的并发策略**，乐观锁在Java中是通过使用**无锁编程**来实现，最常使用的**CAS操作**。
* 比如，**线程安全**的原子类的自增操作，就是通过循环的CAS操作实现的。

<center>

![乐观锁与悲观锁](https://img-blog.csdnimg.cn/20190811110013859.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTQ1Mzg=,size_16,color_FFFFFF,t_70)
</center>

* **悲观锁**

1. 对共享数据进行访问时，悲观锁**总是认为一定会有其他线程修改数据**。如果不加锁，肯定会出问题。
2. 因此，悲观锁**无论是否出现共享数据的争用**，在访问数据时都会先加锁。

* Java中**同步互斥**都是采用这种**悲观的并发策略**，**synchronized关键字和Lock接口的实现类都是悲观锁。**

#### 2. 独占锁和共享锁

* **独占锁**
1. 又叫排它锁，同一个锁对象，**同一时刻只允许一个线程获取到锁。**
2. 如果线程T对数据A加上独占锁后，其他线程不能对该数据再加任何类型的锁（包括独占锁和共享锁），自己可以对数据进行读操作或者写操作。
3. 独占锁允许线程对数据进行读写操作。

* Java中的 **synchronized关键字、Mutex、ReentrantLock、ReentrantReadWriteLock** 中写锁，都是独占锁。  

* **共享锁**

1. 同一个所对象，**同一时刻允许多个线程获取到锁。**
2. 线程T对数据A加上共享锁，则其他线程只能对数据A加共享锁，不能加独占锁。
3. 共享锁只允许对数据进行**读操作。**

* java中ReentrantReadWriteLock中**读锁**是共享锁。
* ReentrantReadWriteLock**读写锁的获取**：

1. **同步状态不为0**，如果有其他线程获取到读锁或者当前线程不是持有写锁的线程，**则获取写锁失败**进入阻塞状态；否则，**当前线程是持有写锁的线程**，直接通过setState()方法增加写状态。
2. **同步状态为0**，直接通过compareAndSetState()方法实现写状态的CAS增加，并将当前线程设置为持有写锁的线程。
3. 如果有**其他线程获取到了写锁**，则**获取读锁失败**进入阻塞状态。
4. 如果写锁未被获取或者该线程为持有写锁的线程，则获取读锁成功，通过compareAndSetState()方法实现读状态的CAS增加


* 独占锁和共享锁都是**通过AQS实现**的，tryAcquire()或者tryAcquireShared()方法支持独占式或者共享式的获取同步状态。



#### 3. 公平锁和非公平锁
* **公平锁**
1. 当锁被释放，按照阻塞的先后顺序获取锁，即同步队列**头节点**中的线程将获取锁。
2. 公平锁可以保证锁的获取按照**FIFO原则**，但需要进行大量的线程切换，导致**吞吐率较低。**

* **非公平锁：**
1. 当锁被释放，所有阻塞的线程都可以争抢获取锁的资格，可能导致先阻塞的线程最后获取锁。
2. 非公平锁虽然可能造成**线程饥饿**，但极少进行线程的切换，保证了**更大的吞吐量**。

* Java中ReentrantLock和ReentrantReadWriteLock支持公平和非公平访问，而synchronized关键字只支持非公平访问。
* 公平与非公平可以通过**构造函数的fair**参数进行指定，默认是false，即**默认为非公平的获取锁。**
* 公平和非公平都是**依靠AQS实现**的，公平使用FairSync同步器，非公平使用NoFairSync同步器。
```java
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

#### 4. 可重入锁和非可重入锁

可重入锁又名递归锁，是指在同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。下面用示例代码来进行分析：

* **可重入锁：**
1. 已经获取锁的线程再次获取该锁而不被锁所阻塞，需要解决**线程再次获取锁和锁的最终释放**两个问题。
2. 可重入锁可以**一定程度的避免死锁**。

<center>

![可重入锁](https://img-blog.csdnimg.cn/20190811153929537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTQ1Mzg=,size_16,color_FFFFFF,t_70)
</center>

* **非可重入锁：**
1. 已经获取锁的线程再次获取该锁，会因为需要等待自身释放锁而被阻塞。
2. 非可重入锁容易造成当前线程死锁，从而使整个队列中线程永久阻塞。


<center>

![非可重入锁](https://img-blog.csdnimg.cn/20190811153940903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTQ1Mzg=,size_16,color_FFFFFF,t_70)
</center>

* Java中的synchronized关键字、ReentrantLock锁和ReentrantReadWriteLock锁都**支持重进入**，其中ReentrantReadWriteLock的**读锁**是支持重进入的**共享锁**，写锁是支持重进入的**独占锁**。


#### 5.无锁VS偏向锁VS轻量级锁VS重量级锁

* synchronized关键字实现同步的基础是**每个对象都是一个锁**，它依靠**对象头**存储锁。
* **无锁、偏向锁、轻量级锁、重量级锁**都是专门针对synchronized关键字设计的、**级别从低到高**的4种状态。
* 注意： **锁状态只能升级，不能降级。**
* 对象头中的第一个字宽叫做Mark Word，用于存储对象的**hashCode、分代年龄、锁**等信息。
* 其中最后**2 bit**的标志位，用于标记锁的状态。根据标志位的不同，可以有如下几种状态：

<center>

![锁状态图](https://img-blog.csdnimg.cn/20190811162250506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NTQ1Mzg=,size_16,color_FFFFFF,t_70)
</center>

**无锁**

* **不对资源进行锁定**，所有的线程都可以访问并修改同一资源，但同一时刻只有一个线程能修改成功。
* **无锁的修改操作依靠循环实现：** 如果没有争用，修改成功并退出循环；否则，循环尝试修改操作，直到成功。
* **无锁无法全面代替有锁**，但在某些场景下具有非常高的性能。
* **无锁的经典实现：** CAS操作。

**偏向锁**

* **出现的原因：**


1. **在无竞争的情况下**，同一线程可能多次进入同一个同步块，即多次获取同一个锁。
2. 如果进入和退出同步块都使用**CAS操作**来加锁和解锁，则会消耗一定的资源。
3. 于是通过CAS操作将线程ID存储到Mark Word中，线程再次进入或退出同步块时，**直接检查Mark Word中是否存储指向当前线程的偏向锁。**如果存储了，则直接进入或退出同步块。

* 偏向锁可以在无竞争的情况下，**尽量减少不必要的轻量级锁执行路径**。轻量级锁的加锁和解锁都需要CAS操作，而偏向锁只有将线程ID存储到Mark Word中时才执行一次CAS操作。
* **偏向锁的释放：**
1. 当有其他线程竞争偏向锁时，持有偏向锁的线程会释放锁偏向锁。
2. 释放时，会根据**锁对象是否处于锁定状态**而恢复到不同的状态。
3. 如果锁对象处于**未锁定状态**，撤销偏向后恢复到**无锁的状态**（0 + 01 ）；如果锁对象处于**锁定状态**，撤销偏向后恢复到**轻量级锁的状态**（00）。

* 偏向锁在JDK1.6及以后，默认是启用的，即-XX:+UseBiasedLocking。可以通过-XX:-UseBiasedLocking关闭偏向锁。

**轻量级锁**

* 多个线程竞争同步资源时，没有获取到资源的线程**自旋等待锁的释放**。

* **加锁过程：**
1. 线程进入同步块时，如果同步对象处于**无锁状态**（0 + 01），JVM 首先在当前线程的栈帧中开辟一块叫做锁记录（Lock Record）的空间，用于存储同步对象的Mark Word的拷贝。这个拷贝加了一个前缀，叫Displaced Mark Word。
2. 然后通过**CAS操作**将同步对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的**owner指针**指向同步对象的Mark Word。
3. 如果这个更新动作成功，则当前线程拥有了该对象的锁，Mark Word中的标志位更新为00，表示对象处于轻量级锁定状态。
4. 如果更新动作失败，JVM首先会检查同步对象的Mark Word**是否指向当前线程的栈帧**。如果是，说明当前线程已经持有了该对象的锁，可以直接进入同步块继续执行；否则，说明存在多线程竞争锁。


* **轻量级锁升级为重量级锁：**

1. 若当前只有一个线程在等待，则通过自旋进行等待。自旋超过一定的次数，轻量级锁升级为重量级锁。
2. 若一个线程持有锁，一个线程自旋等待锁，又有第三个线程想要获取锁，轻量级锁升级为重量级锁。


* **锁的释放：**
1. 通过**CAS操作**，将Lock Record中的Displaced Mark Word与对象中的Mark Word进行替换。
2. 替换成功，**同步状态完成**；替换失败，说明有其他线程尝试获取过该锁，**释放锁的同时需要唤醒被挂起的线程**。


**重量级锁**

* 多线程竞争同步资源时，没有获取到资源的线程**阻塞等待锁的释放。**
1. 轻量级锁升级为重量级锁，锁的标志位变成10，Mark Word中存储的是指向重量级锁的指针。
2. 所有等待锁的线程都会进入阻塞状态。



#### 6. 自旋锁与自适应自旋锁

* **自旋锁：**
1. 阻塞或唤醒一个线程都需要从用户态切换到内核态去完成，会对性能造成很大影响。
2. 有时一个线程持有锁的时间很短，如果在很短的时间内让后续获取锁的线程都进入阻塞态，这是很不值得。
3. 可以让后续线程持有CPU时间等待一会，这个等待需要执行忙循环（自旋） 来实现。
4. 自旋等待的时间由自旋次数来衡量，默认为10，可以使用-XX:PreBlockSpin来进行设置。
5. 如果在自旋等待中，持有锁的线程释放该锁，当前线程可以不必阻塞直接获取同步资源。
6. 如果超过自旋次数仍未获取成功，则使用传统的方法将其阻塞。

* **自旋锁的实现原理：** 循环的CAS操作
* **自旋锁的缺点：**
1. 自旋锁虽然避免了线程的切换开销，但是会占用CPU时间。
2. 如果每个等待获取锁的线程总是自旋规定的次数，却又没有等到锁的释放，这样就白白浪费了CPU时间。

* 自旋锁在JDK1.4.2中引入，默认是关闭的；在JDK1.6中变成默认开启，并为了解决自旋锁中浪费CPU资源的问题，而引入了自适应自旋锁。  


* **自适应自旋锁：**

1. 自适应意味着**自旋的次数不再固定**，而是根据**上一次在同一个锁自旋的次数**和**锁的拥有者的状态来决定**。
2. 如果在同一个锁对象上自旋刚刚成功获取过锁，并持有锁的线程处于运行状态，则可以认为**这一次自旋也很可能成功**，允许它自旋更长的时间。
3. 如果在一个锁上，**自旋很少成功**，则下一次可以**省略自旋过程**，直接阻塞线程，避免浪费处理器资源。

### 参考
[Java高并发之锁总结、常见的面试问题](https://blog.csdn.net/u014454538/article/details/99172899)


