---
title: Redis内存淘汰机制
author: Marlowe
tags: Redis
categories: NoSQL
abbrlink: 63337
date: 2021-04-16 20:20:38
---

<!--more-->

### Redis 提供 6 种数据淘汰策略

1. **volatile-lru（least recently used）：** 从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
2. **volatile-ttl：** 从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. **volatile-random：** 从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. **allkeys-lru（least recently used）：** 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）
5. **allkeys-random：** 从数据集（server.db[i].dict）中任意选择数据淘汰
6. **no-eviction：** 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！


### 4.0 版本后增加以下两种

7. **volatile-lfu（least frequently used）：** 从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰
8. **allkeys-lfu（least frequently used）：** 当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key

### 淘汰策略详解

#### redis过期键的删除策略

如果一个键是过期的，那它到了过期时间之后是不是马上就从内存中被被删除呢？

如果回答yes，你自己走还是面试官送你？

如果不是，那过期后到底什么时候被删除呢？？是个什么操作？

#### 三种不同的删除策略

* 定时删除 - 总结：对CPU不友好，用处理器性能换取存储空间（拿时间换空间）
* 惰性删除 - 总结：对memory不友好，用存储空间换取处理器性能（拿空间换时间）
* 上面两种方案都走极端 - 定期删除 - 定期抽样key，判断是否过期（存在漏网之鱼）

#### 定时删除

Redis不可能时时刻刻遍历所有被设置了生存时间的key，来检测数据是否已经到达过期时间，然后对它进行删除。

立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。但是立即删除对cpu是最不友好的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力，让CPU心累，时时需要删除，忙死。

这会产生大量的性能消耗，同时也会影响数据的读取操作。

#### 惰性删除

数据到达过期时间，不做处理。等下次访问该数据时，

如果未过期，返回数据；

发现已过期，删除，返回不存在。

惰性删除策略的缺点是，它**对内存是最不友好的。**

如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键不被删除，它所占用的内存就不会释放。

在使用惰性删除策略时，如果数据库中有非常多的过期键，**而这些过期键又恰好没有被访问到的话**，那么它们也许永远也不会被删除（除非用户手动执行FLUSHDB），我们甚至可以将这种情况看作是一种内存泄漏 – 无用的垃圾数据占用了大量的内存，而服务器却不会自己去释放它们，这对于运行状态非常依赖于内存的Redis服务器来说，肯定不是一个好消息。

#### 定期删除

定期删除策略是前两种策略的折中：

定期删除策略每隔一段时间执行一次删除过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。

周期性轮询Redis库中的时效性数据，来用随机抽取的策略，利用过期数据占比的方式控制删除频度

特点1：CPU性能占用设置有峰值，检测频度可自定义设置

特点2：内存压力不是很大，长期占用内存的冷数据会被持续清理

总结：周期性抽查存储空间（**随机抽查，重点抽查**）

举例：

redis默认每个100ms检查，是否有过期的key，有过期key则删除。**注意**：redis不是每隔100ms将所有的key检查一次而是随机抽取进行检查(如果每隔100ms，全部key进行检查，redis直接进去ICU)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。

定期删除策略的难点是确定删除操作执行的时长和频率:如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除策略，以至于将CPU时间过多地消耗在删除过期键上面。如果删除操作执行得太少，或者执行的时间太短，定期删除策略又会和惰性删除束略一样，出现浪费内存的情况。因此，如果采用定期删除策略的话，服务器必须根据情况，合理地设置删除操作的**执行时长和执行频率**。

**上述步骤都过堂了，还有漏洞吗？**

1. 定期删除时，从来没有被抽查到
2. 惰性删除时，也从来没有被点中使用过

上述2步骤====>大量过期的key堆积在内存中，导致redis内存空间紧张或者很快耗尽

**必须要有一个更好的兜底方案**

内存淘汰策略登场（Redis 6.0.8版本）

* noeviction：不会驱逐任何key
* volatile-lfu：对所有设置了过期时间的key使用LFU算法进行删除
* volatile-Iru：对所有设置了过期时间的key使用LRU算法进行删除
* volatile-random：对所有设置了过期时间的key随机删除
* volatile-ttl：删除马上要过期的key
* allkeys-lfu：对所有key使用LFU算法进行删除
* allkeys-Iru：对所有key使用LRU算法进行删除
* allkeys-random：对所有key随机删除

**上面总结**

* 2*4得8
* 2个维度
  * 过期键中筛选
  * 所有键中筛选
* 4个方面
  * LRU
  * LFU
  * random
  * ttl（Time To Live）
* 8个选项

如何配置，修改

* 命令
  * config set maxmemory-policy noeviction
  * config get maxmemory
* 配置文件 - 配置文件redis.conf的maxmemory-policy参数
